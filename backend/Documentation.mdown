# CRI COVE Backend Documentation

# Project Structure

## File Structure
<pre>
├── Documentation.mdown
├── README
├── application
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── models
│   │   ├── __init__.py
│   │   ├── __init__.pyc
│   │   ├── datasample.py
│   │   ├── datasample.pyc
│   │   ├── dataset.py
│   │   ├── dataset.pyc
│   │   ├── relation.py
│   │   ├── relation.pyc
│   │   ├── test.py
│   │   └── test.pyc
│   ├── utils
│   │   ├── __init__.py
│   │   ├── __init__.pyc
│   │   ├── uploadDataset.py
│   │   └── uploadDataset.pyc
│   └── views
│       ├── __init__.py
│       ├── __init__.pyc
│       └── api
│           ├── __init__.py
│           ├── __init__.pyc
│           ├── test_api.py
│           └── test_api.pyc
├── application.py
├── db_create.py
└── requirements.txt
</pre>

This is the overall file structure of this project. 

The application/ contains code for the backend server. application.py start the web server and db_create.py create the database with the definition (models) in the implementation.

The requirements.txt contains all dependencies of this project.

## Implementation Structure
We use Model-View style to implement the backend structure. application/models/ contains all models and relational table for the project. application/views contains all views for the project.

### Models

#### Dataset

Dataset object keeps tracks of each data set record we stored in the database. All data will also store in the database as table datasets.

The current design of the database is:
|id |    name    | url | description | license | is_local | creator | creation_date | contact_name | contact_email | purpose | notes | search_vector|
|:-:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|   
|integer, primary key, auto increment| 128 byte string, unique| 128 byte string | text | 128 byte string | boolean | 128 byte string | date | 128 byte string | 128 byte string | 128 byte string | text | search vector for text search |

The data variable in Dataset object contains all Datasample object that this object holds, the document will explain this later. The DatasetQuery object declared in dataset.py is used for declaring the search_vector in the database.

#### Datasample

Datasample object keeps track of each data sample record we stored in the database. All data will also store in the database as table datasamples.

The current design of the database is:
|id | path | type | format | size | length| comment|
|:-:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|   
|integer, primary key, auto increment| 128 byte string | 128 byte string | 128 byte string | integer in byte | integer in seconds | text |

#### Relationship Table

##### Datasample to Dataset
This table is for mapping the Datasample into each Dataset object. This table contains id for both dataset entry and datasample entry; thus each datasample are mapped to different dataset. A datasample can be mapped to different dataset and this solves the problem of different datasets are overlapping with each other.

In the Dataset object, the data member variable keeps track the Datasample that is mapped to this Dataset by using the convention of SQLAlchemy. 


More relationship table will be added as the project goes.

### Views

The View can contain different "Blueprint" to separate the purpose of each view. Currently, it only has an api blueprint but more will be added as project goes.

#### API Blueprint

All views under this blueprint will be registered under [/api/](/api/). For example, the API for testing purpose will under [/api/test](/api/test).

##### Test API

###### Connection Test
route: [/api/test/connection](/api/test/connection)

Check whether we have the connection with the database by manipulating test table.

GET: /api/test/connection?test_id=xxx
     /api/test/connection?test_value=xxx

It will return a response based on search query.

POST: /api/test/connection

JSON object: {"test_value" : xxx}

It will return a response 200 when insert is successful.
###### Dataset Test
GET: /api/test/dataset?name=xxx 

It will return a response based on search query

POST: /api/test/dataset

JSON object: 
{
      "contact_email": "xxx", 
      "contact_name": "xxx", 
      "creation_date": "xxx", 
      "creator": "xxx", 
      "description": "xxx", 
      "is_local": false, 
      "license": "xxx", 
      "name": "xxx", 
      "notes:": "xxx", 
      "purpose": "xxx", 
      "url": "xxx"
}
It will return a response 200 when dataset insert is successful.
###### Datasample Test

GET: /api/test/datasample?name=xxx

It will return a response based on search query

POST: /api/test/datasample

JSON object:
{
  "dname": "xxx",
  "comment": "xxx", 
  "format": "xxx", 
  "length": x, 
  "path": "xxx.xxx", 
  "size": x, 
  "type": "xxx"
}
It will return a response 200 when dataset insert is successful.
###### Insertion Test
GET: /api/test/insertion?name=xxx 

It will return a response based on search query

POST: /api/test/insertion

JSON object:
{
    "dataset_name" : "xxx",
    "data_sample_path" : "xxx"
}
It will return a response 200 when dataset insert is successful.

More views will added as the project goes.

## How to start

1. virtualenv venv
2. pip install -r requirement.txt
3. python db_create.db (Assume already start the psqld and has correct username and password)
4. python application.py
